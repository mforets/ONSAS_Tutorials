var documenterSearchIndex = {"docs":
[{"location":"tutorials/CantileverBeam/cantileverBeam/","page":"-","title":"-","text":"%## Uniform curvature cantilever beam %#–- %# %#In this tutorial, the Uniform curvature cantilever example and its resolution using ONSAS are described. The aim of this example is to validate the static co-rotational 3D beam implementation by comparing the results provided by ONSAS with the analytical solution.  The Octave script of this example is available at this url. %# %#The problem consists in a beam, with one free end (right) submitted to a nodal moment M, and the other end (left) constrained (welded), as it is shown in the figure. %# %#@raw html %#<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/tutorials/CantileverBeam/cantileverBeam.svg\" alt=\"structure diagram\" width=\"500\"/> %# %# %#Before defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar geometry and material parameters are defined. close all, clear all ; % add path addpath( [ pwd '/../../src'] ); % material scalar parameters E = 200e9 ;  nu = 0.3 ; % geometrical scalar parameters l = 10 ; ty = .1 ;  tz = .1 ; % the number of elements of the mesh numElements = 10 ; %# %### MEBI parameters %#––––––––– %# %#The modelling of the structure begins with the definition of the Material-Element-BoundaryConditions-InitialConditions (MEBI) parameters. %#### materials %# Since the example contains only one rod the fields of the materials struct will have only one entry. Although, it is considered constitutive behavior according to the SaintVenantKirchhoff law: materials.hyperElasModel  = { '1DrotEngStrain'} ; materials.hyperElasParams = { [ E nu ] } ; %# The density is not defined, therefore it is considered as zero (default), then no inertial effects are considered (static analysis). %# %#### elements %# %#Two different types of elements are considered, node and beam. The nodes will be assigned in the first entry (index 1) and the beam at the index 2. The elemType field is then: elements.elemType = { 'node','frame' } ; %# for the geometries, the node has not geometry to assign (empty array), and the truss elements will be set as a rectangular-cross section with t_y and t_z cross-section dimensions in y and z directions, then the elemTypeGeometry field is: elements.elemTypeGeometry = { [], [2 ty tz ] }; elements.elemTypeParams = { [], 1 }; %### boundaryConds %# %# The elements are submitted to two different BC settings. The first BC corresponds to a welded condition (all 6 dofs set to zero), and the second corresponds to an incremental nodal moment, where the target load produces a circular form of the deformed beam.  %# The scalar values of inertia I_z is computed. Iy = tytz^3/12 ; boundaryConds.loadsCoordSys = { []        ; 'global'   } ; boundaryConds.loadsTimeFact = { []        ; @(t) EIy2pi/l t } ; boundaryConds.loadsBaseVals = { []        ; [ 0 0 0 -1 0 0 ] } ; boundaryConds.imposDispDofs = { [ 1 2 3 4 5 6 ] ; []         } ; boundaryConds.imposDispVals = { [ 0 0 0 0 0 0 ] ; []         } ; %# %# %### initial Conditions %# homogeneous initial conditions are considered, then an empty struct is set: initialConds                = struct() ; %# %### mesh parameters %#The coordinates of the nodes of the mesh are given by the matrix: mesh.nodesCoords = [ (0:(numElements))'l/numElements  zeros(numElements+1,2) ] ; %#The connectivity is introduced using the conecCell. Each entry of the cell contains a vector with the four indexes of the MEBI parameters, followed by the indexes of the nodes of the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized: mesh.conecCell = { } ; %# then the first two nodes are defined, both with material zero (since nodes dont have material), the first element type (the first entry of the cells of the elements struct), and the first entry of the cells of the boundary conditions struct. No non-homogeneous initial condition is considered (then zero is used) and finally the node is included. mesh.conecCell{ 1, 1 } = [ 0 1 1 0  1   ] ; %# the following case only differs in the boundary condition and the node number mesh.conecCell{ 2, 1 } = [ 0 1 2 0  numElements+1 ] ; %# the beam elements are formed by the first material, the second type of element, and no boundary conditions are applied to any element. for i=1:numElements,   mesh.conecCell{ i+2,1 } = [ 1 2 0 0  i i+1 ] ; end %# %### analysisSettings analysisSettings.methodName    = 'newtonRaphson' ; analysisSettings.deltaT        =   0.1  ; analysisSettings.finalTime     =   1.0  ; analysisSettings.stopTolDeltau =   1e-6 ; analysisSettings.stopTolForces =   1e-6 ; analysisSettings.stopTolIts    =   10   ; %# %### otherParams otherParams.problemName = 'uniformCurvatureCantilever'; otherParams.plotParamsVector = [ 3 ] ; otherParams.controlDofs = [ numElements+1  4 ] ; %### Analysis case 1: NR with Rotated Eng Strain %# In the first case ONSAS is run and the solution at the dof (angle of node B) of interest is stored: [matUs, loadFactorsMat] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;","category":"page"},{"location":"tutorials/CantileverBeam/cantileverBeam/","page":"-","title":"-","text":"%# the control dof to verificate the solution is the node angle B, this corresponds to the following dof number: angleControlDof      = (numElements+1)*6 - 2; controlDispsNREngRot =  -matUs(angleControlDof,:) ; loadFactorsNREngRot  =  loadFactorsMat(:,2) ; %# and the analytical value of the load factors is computed analyticLoadFactorsNREngRot = @(w) E * Iy * w / l ;","category":"page"},{"location":"tutorials/CantileverBeam/cantileverBeam/","page":"-","title":"-","text":"%### Results verification %#–- %# verifBoolean = norm( analyticLoadFactorsNREngRot( controlDispsNREngRot) ...                      - loadFactorsNREngRot' )  ...                     < ( norm( analyticLoadFactorsNREngRot( controlDispsNREngRot) ) * 1e-4 )  %# %# lw = 2.0 ; ms = 11 ; plotfontsize = 22 ; figure plot( controlDispsNREngRot, analyticLoadFactorsNREngRot( controlDispsNREngRot) ,'b-x' , 'linewidth', lw,'markersize',ms ) hold on, grid on plot( controlDispsNREngRot, loadFactorsNREngRot, 'k-o' , 'linewidth', lw,'markersize',ms ) labx = xlabel('Displacement');   laby = ylabel('lambda') ; legend('analytic','NR-RotEng','location','North') set(gca, 'linewidth', 1.2, 'fontsize', plotfontsize ) set(labx, 'FontSize', plotfontsize); set(laby, 'FontSize', plotfontsize) ; print('verifCantileverBeam.png','-dpng') %# %#@raw html %#<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/tutorials/CantileverBeam/verifCantileverBeam.png\" alt=\"plot check\" width=\"500\"/> %# %# %#","category":"page"},{"location":"uniaxialExtension/#Example-uniaxialSolid","page":"Uniaxial extension","title":"Example uniaxialSolid","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"In this example an elastic solid is submitted to a uniaxial extension test. The problem is inspired by Exercise 4 from section 6.5 in (Holzapfel,2000). The geometry and tension applied are shown in the figure, where the Lx, Ly and Lz are the dimensions and the tension p is applied on the face x=Lx, as nominal traction (see (Holzapfel,2000)).","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/diagramSolidUniaxialHTML.svg\" alt=\"structure diagram\" width=\"500\"/>","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"\\begin{center}\n\\def\\svgwidth{0.7\\textwidth}\n\\input{diagramSolidUniaxialPDF.pdf_tex}\n\\end{center}","category":"page"},{"location":"uniaxialExtension/#Analytic-solution","page":"Uniaxial extension","title":"Analytic solution","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"Let us consider a uniform deformation with parametric deformation gradient and corresponding Green-Lagrange strain tensor given by","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"textbfF = left beginmatrix alpha  0  0  0  beta  0  0  0  beta endmatrix right\nqquad\ntextbfE = left  beginmatrix frac12 left(alpha^2 -1right)  0  0  0   frac12 left(beta^2 -1right)  0  0  0   frac12 left(beta^2 -1right) endmatrix right","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"The second Piola-Kirchhoff tensor textbfS is given by","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"textbfS( textbfE ) = p_1 tr(textbfE) textbfI + 2 p_2 textbfE","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"then, using the relation textbfP=textbfFtextbfS, the P_yy component is computed and set zero (by the boundary conditions)","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"P_yy( textbfE ) =\np_1 beta left(\n             frac12 left(alpha^2 -1 right) + left( beta^2 -1right)\n right) + 2 p_2 beta (frac12 left(beta^2 -1 right)) = 0","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"then, using that betaneq0 (since textdet( textbfF ) neq0), we obtain","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":" p_1 frac12 left(alpha^2 -1 right)\n = - (p_1+p_2) left(beta^2 -1 right)","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"then using p_2 and p_1 expressions we obtain","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":" left(beta^2 -1 right) = -nu left(alpha^2 -1 right)","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"The axial component of the nominal stress is","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"P_xx( textbfE ) =\np_1 alpha left(\n             frac12 left(alpha^2 -1 right) + left( beta^2 -1right)\n right) + 2 p_2 alpha (frac12 left(alpha^2 -1 right)) = 0","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"and substituting we obtain","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"P_xx( alpha ) =\np_1 alpha frac1-2nu2 left(alpha^2 -1 right) + p_2 alpha left(alpha^2 -1 right) =\n left( fracE nu(1+nu)2  + fracE(1+nu)2 right)  alpha left(alpha^2 -1 right)","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"thus, considering the axial displacement u and using the stretch definition alpha = (1+uLx), we obtain","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"P_xx( u ) =\n fracE2  left( left( 1+fracuLx right)^3 - left( 1+ fracuLx right) right)","category":"page"},{"location":"uniaxialExtension/#Numerical-solution","page":"Uniaxial extension","title":"Numerical solution","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"Before defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar geometry and material parameters are defined.","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"clear all, close all\n% add path\naddpath( genpath( [ pwd '/../../src'] ) ) ;\n% scalar parameters\nE = 1 ; nu = 0.3 ; p = 3 ; Lx = 2 ; Ly = 1 ; Lz = 1 ;","category":"page"},{"location":"uniaxialExtension/#MEBI-parameters","page":"Uniaxial extension","title":"MEBI parameters","text":"","category":"section"},{"location":"uniaxialExtension/#materials","page":"Uniaxial extension","title":"materials","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"The material of the solid considered is the Saint-Venant-Kirchhoff with Lamé parameters computed as","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"lambda = E*nu/((1+nu)*(1-2*nu)) ; mu = E/(2*(1+nu)) ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"since only one material is considered, the structs defined for the materials contain only one entr","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"materials.hyperElasModel = {'SVK'} ;\nmaterials.hyperElasParams = { [ lambda mu ] } ;","category":"page"},{"location":"uniaxialExtension/#elements","page":"Uniaxial extension","title":"elements","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"In this model two kinds of elements are used: tetrahedrons for the solid and triangles for introducing the external loads. Since two kinds of elements are used, the structs have length 2:","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"elements.elemType = { 'triangle', 'tetrahedron' } ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"since triangle and tetrahedron elements dont have specific parameters the struct entries contain empty vectors","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"elements.elemTypeParams = { [];[] } ;\nelements.elemTypeGeometry = { [];[] } ;","category":"page"},{"location":"uniaxialExtension/#boundaryConds","page":"Uniaxial extension","title":"boundaryConds","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"in this case four BCs are considered, one corresponding to a load and three to displacements.","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"boundaryConds.loadsCoordSys = {'global'; [] ; [] ; [] } ;\nboundaryConds.loadsTimeFact = { @(t) t ; [] ; [] ; []} ;\nboundaryConds.loadsBaseVals = { [p 0 0 0 0 0 ] ; [] ; [] ; [] } ;\nboundaryConds.imposDispDofs = { [] ; [1] ; [3] ; [5] } ;\nboundaryConds.imposDispVals = { [] ; [0] ; [0] ; [0] } ;","category":"page"},{"location":"uniaxialExtension/#initialConds","page":"Uniaxial extension","title":"initialConds","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"since no initial non-homogeneous initial conditions are used, an empty struct is used .","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"initialConds = struct();","category":"page"},{"location":"uniaxialExtension/#Mesh","page":"Uniaxial extension","title":"Mesh","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"An 8-node mesh is considered with its connectivity matrix","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/solidCubeMeshHTML.svg\" alt=\"structure diagram\" width=\"500\"/>","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"\\begin{center}\n\\def\\svgwidth{0.6\\textwidth}\n\\input{solidCubeMeshPDF.pdf_tex}\n\\end{center}","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"The connectivity matrix is given by the following matrix","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"mesh.nodesCoords = [ 0    0    0 ; ...\n                     0    0   Lz ; ...\n                     0   Ly   Lz ; ...\n                     0   Ly    0 ; ...\n                     Lx   0    0 ; ...\n                     Lx   0   Lz ; ...\n                     Lx  Ly   Lz ; ...\n                     Lx  Ly    0 ] ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"and the connectivity cell is defined as follows with the MEBI integer parameters for each element. All the eight triangle elements are considered with no material (since they are used only to include load) and the following six elements are solid SVK material tetrahedrons.","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"mesh.conecCell = {[ 0 1 1 0    5 8 6   ]; ... % loaded face\n                  [ 0 1 1 0    6 8 7   ]; ... % loaded face\n                  [ 0 1 2 0    4 1 2   ]; ... % x=0 supp face\n                  [ 0 1 2 0    4 2 3   ]; ... % x=0 supp face\n                  [ 0 1 3 0    6 2 1   ]; ... % y=0 supp face\n                  [ 0 1 3 0    6 1 5   ]; ... % y=0 supp face\n                  [ 0 1 4 0    1 4 5   ]; ... % z=0 supp face\n                  [ 0 1 4 0    4 8 5   ]; ... % z=0 supp face\n                  [ 1 2 0 0    1 4 2 6 ]; ... % tetrahedron\n                  [ 1 2 0 0    6 2 3 4 ]; ... % tetrahedron\n                  [ 1 2 0 0    4 3 6 7 ]; ... % tetrahedron\n                  [ 1 2 0 0    4 1 5 6 ]; ... % tetrahedron\n                  [ 1 2 0 0    4 6 5 8 ]; ... % tetrahedron\n                  [ 1 2 0 0    4 7 6 8 ]  ... % tetrahedron\n                } ;","category":"page"},{"location":"uniaxialExtension/#Analysis-parameters","page":"Uniaxial extension","title":"Analysis parameters","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"analysisSettings.methodName    = 'newtonRaphson' ;\nanalysisSettings.stopTolIts    = 30      ;\nanalysisSettings.stopTolDeltau = 1.0e-12 ;\nanalysisSettings.stopTolForces = 1.0e-12 ;\nanalysisSettings.finalTime      = 1       ;\nanalysisSettings.deltaT        = .1      ;","category":"page"},{"location":"uniaxialExtension/#Output-parameters","page":"Uniaxial extension","title":"Output parameters","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"otherParams.plotsFormat = 'vtk' ;\notherParams.problemName = 'uniaxialExtension_Manual' ;\n%~ printflag = 2 ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"[matUs, loadFactorsMat] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;","category":"page"},{"location":"uniaxialExtension/#Results","page":"Uniaxial extension","title":"Results","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"lambda(t) = frac1p fracE2  left( left( 1+fracuLx right)^3 - left( 1+ fracuLx right) right)","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"\nanalyticCheckTolerance = 1e-6 ;\nanalyticFunc           = @(w) 1/p * E * 0.5 * ( (1 + w/Lx).^3 - (1+w/Lx) ) ;\ndisps = matUs(6*6+1,:) ;\nanalyticVals = analyticFunc(disps) ;\n%\nverifBoolean = ( norm( analyticVals - loadFactorsMat') / norm( analyticVals) ) < analyticCheckTolerance\n","category":"page"},{"location":"uniaxialExtension/#plot","page":"Uniaxial extension","title":"plot","text":"","category":"section"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"lw = 2.0 ; ms = 11 ; plotfontsize = 22 ;\nfigure, hold on, grid on\nplot( disps, loadFactorsMat, 'k-o' , 'linewidth', lw,'markersize',ms )\nplot( disps, analyticVals, 'b-x' , 'linewidth', lw,'markersize',ms )\nlabx = xlabel('Displacement');   laby = ylabel('$\\lambda$') ;\nlegend('Numeric','Analytic','location','North')\nset(gca, 'linewidth', 1.2, 'fontsize', plotfontsize )\nset(labx, 'FontSize', plotfontsize); set(laby, 'FontSize', plotfontsize) ;\nprint('verifUniaxial.png','-dpng')","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"```","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"return","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% ––––––––––––––––––––––––––––","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"clear iniMatUs","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"controlDispsValsCase1         = controlDisps  ; loadFactorAnalyticalValsCase1 = analyticVals  ; loadFactorNumericalValsCase1  = numericalVals ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"close all","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% –––––––––––––––––––––––––––– % solid model using gmsh mesh, local tension load and complex step % ––––––––––––––––––––––––––––","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"problemName = 'uniaxialExtensionGMSHComplexStep' ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"[ Nodes, Conec ] = meshFileReader( 'geometry_uniaxialExtension.msh' ) ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"loadsParams{1,1}    = [ 0 1  0 0 0 0 p 0 ] ; % local coords appliend tension","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"elementsParams{2,1} = [ 4 1 ] ; % complex step constitutive tensor","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"plotParamsVector = [ 0 ] ; analyticSolFlag        = 0 ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% run ONSAS ONSAS","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"controlDispsValsCase2         = controlDisps  ; loadFactorNumericalValsCase2  = numericalVals ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% –––––––––––––––––––––––––––– % truss element model % ––––––––––––––––––––––––––––","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"problemName = 'uniaxialExtension_truss' ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"Nodes = [ 0    0    0 ; ...           Lx   0    0   ...         ] ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"Conec = {[ 0 1 0 0 1   1   ] ; ... % fixed node          [ 0 1 1 0 2   2   ] ; ... % loaded node          [ 1 2 0 1 0   1 2 ]   ... % truss element         } ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% ====================================================================== % –- MELCS parameters –-","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"materialsParams = cell(1,1) ; % M elementsParams  = cell(1,1) ; % E loadsParams     = cell(1,1) ; % L crossSecsParams = cell(1,1) ; % C springsParams   = cell(1,1) ; % S","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% –- Material parameters –- E = 1 ; nu = 0.3 ; materialsParams{1} = [ 0 2 E nu ] ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% –- Element parameters –- elementsParams = { 1  ; [ 2 0 ]} ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% –- Load parameters –- loadsParams{1,1} = [ 1 1  p 0 0 0 0 0 ] ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% –- CrossSection parameters –- crossSecsParams = { [ 2 Ly Lz] } ; %","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% ––––––––––––––––––––––––––––––––––– % –- springsAndSupports parameters –- springsParams{1, 1} = [ inf 0  inf 0   inf 0 ] ; springsParams{2, 1} = [ 0   0  inf 0   inf 0 ] ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% ======================================================================","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"plotParamsVector       = [ 0 ] ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"controlDofs = [ 2 1 1 ] ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"%% run ONSAS ONSAS","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"controlDispsValsCase3         = controlDisps  ; %~ loadFactorNumericalValsCase3  = numericalVals .* (1+controlDisps) / Lx ; loadFactorNumericalValsCase3  = numericalVals ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% ––––––––––––––––––––––––––––––––––– % –- plots –- lw = 2.0 ; ms = 10 ; plotfontsize = 22 ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"figure, grid on, hold on","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"plot( controlDispsValsCase1, ...       loadFactorAnalyticalValsCase1 ,'b-o' , 'linewidth', lw,'markersize',ms )","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"plot( controlDispsValsCase1, ...       loadFactorNumericalValsCase1  ,'k-s' , 'linewidth', lw,'markersize',ms)","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"plot( controlDispsValsCase2, ...       loadFactorNumericalValsCase2  ,'r-x' , 'linewidth', lw,'markersize',ms)","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"plot( controlDispsValsCase3, ...       loadFactorNumericalValsCase3  ,'g–' , 'linewidth', lw,'markersize',ms)","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"labx = xlabel('Displacement');   laby = ylabel('lambda') ; legend('analytic Sol','numerical Sol 1','numerical Sol 2','numerical Sol 3','location','North') set(gca, 'linewidth', 1.2, 'fontsize', plotfontsize ) set(labx, 'FontSize', plotfontsize); set(laby, 'FontSize', plotfontsize) ; %~ print( [ 'plotsExtensionSVK' ] ,'-dpdflatex','-tight') ; print( [ 'plotsExtensionSVK.png' ] ,'-dpng') ;","category":"page"},{"location":"uniaxialExtension/","page":"Uniaxial extension","title":"Uniaxial extension","text":"% –––––––––––––––––––––––––––––––––––","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"-","title":"-","text":"%## Static Von Mises Truss example %#–- %# %#In this tutorial, the Static Von Mises Truss example and its resolutions using ONSAS are described. The aim of this example is to validate the Newton-Raphson method implementation by comparing the results provided by ONSAS with the analytical solution. The Octave script of this example is available at this url. %#  %#The structural model is formed by two truss elements with length L as it is shown in the figure, with the node 2 submitted to a nodal load P and restrained to move in the x-z plane and nodes 1 and 3 fixed. %# %#@raw html %#<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/tutorials/StaticVonMisesTruss/vonMisesTruss.svg\" alt=\"structure diagram\" width=\"500\"/> %# %# %#Before defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar auxiliar parameters are defined. close all, clear all ; addpath( [ pwd '/../../src'] );  E = 210e9 ;  A = 2.5e-3 ; ang1 = 65 ; L = 2 ; nu = 0 ; % x and z coordinates auxx = cos( ang1pi/180 ) * L ;  auxz = sin( ang1pi/180 ) * L ; %# %### MEBI parameters %#––––––––– %# %#The modelling of the structure begins with the definition of the Material-Element-BoundaryConditions-InitialConditions (MEBI) parameters. %# %#### materials %# Since both bars are formed by the same material all the fields of the materials struct will have only one entry. contains only one vector. The constitutive behavior is the SaintVenantKirchhoff: materials.hyperElasModel  = { '1DrotEngStrain'} ; materials.hyperElasParams = { [ E nu ] } ; %# and the parameters of this model are the Young modulus and Poisson ratio. %# %#### elements %# %#Two different types of elements are considered, node and truss. The nodes will be assigned in the first entry (index 1) and the truss at the index 2. The elemType field is then: elements.elemType = { 'node','truss' } ; %# for the geometries, the node has no geometry to assign (empty array), and the truss elements will be set as a square-cross section, then the elemTypeGeometry field is: elements.elemTypeGeometry = { [], [2 sqrt(A) sqrt(A) ] }; elements.elemTypeParams = { [], 1 }; %# %#### boundaryConds %# %# The elements are submitted to two different BC settings. The nodes 1 and 3 are fixed without applied loads (first BC), and node 2 has a constraint in displacement and an applied load (second BC). The load factor function of the second BC is set so that the target load 1.5e8 is reached at 1 second. The density is set to zero, then no inertial effects are considered. %# boundaryConds.loadsCoordSys = { []        ; 'global'   } ; boundaryConds.loadsTimeFact = { []        ; @(t) 1.5e8t     } ; boundaryConds.loadsBaseVals = { []        ; [ 0 0 0 0 -1 0 ] } ; boundaryConds.imposDispDofs = { [ 1 3 5 ] ; 3          } ; boundaryConds.imposDispVals = { [ 0 0 0 ] ; 0          } ; %# %#### initial Conditions %# homogeneous initial conditions are considered, then an empty struct is set: initialConds                = struct() ; %# %### mesh parameters %#––––––––– %#The coordinates of the nodes of the mesh are given by the matrix: mesh.nodesCoords = [      0  0     0  ; ...                        auxx  0  auxz  ; ...                      2auxx  0     0  ] ; %#The connectivity is introduced using the conecCell. Each entry of the cell contains a vector with the four indexes of the MEBI parameters, followed by the indexes of the nodes of the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized: mesh.conecCell = { } ; %# then the first two nodes are defined, both with material zero (since nodes dont have material), the first element type (the first entry of the cells of the elements struct), and the first entry of the cells of the boundary conditions struct. No non-homogeneous initial condition is considered (then zero is used) and finally the node is included. mesh.conecCell{ 1, 1 } = [ 0 1 1 0  1   ] ;  mesh.conecCell{ 2, 1 } = [ 0 1 1 0  3   ] ;  %# the following case only differs in the boundary condition mesh.conecCell{ 3, 1 } = [ 0 1 2 0  2   ] ;  %# the truss elements are formed by the first material, the second type of element, and no boundary condition is applied. mesh.conecCell{ 4, 1 } = [ 1 2 0 0  1 2 ] ; mesh.conecCell{ 5, 1 } = [ 1 2 0 0  2 3 ] ;  %# %### analysisSettings %#––––––––– analysisSettings.methodName    = 'newtonRaphson' ; analysisSettings.deltaT        = 0.1 ; analysisSettings.finalTime     =   1 ; analysisSettings.stopTolDeltau =   1e-6 ; analysisSettings.stopTolForces =   1e-6 ; analysisSettings.stopTolIts    =   10 ; analysisSettings.finalTime     =   1 ; %# %### otherParams %#––––––––– otherParams.problemName = 'staticVonMisesTrussNR'; otherParams.plotParamsVector = [3]; otherParams.controlDofs = [2 5 ]; %# %### Analysis case 1: NR with Rotated Eng Strain %#––––––––– %# In the first case ONSAS is run and the solution at the dof of interest is stored . [matUs, loadFactorsMat] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ; controlDispsNREngRot =  -matUs(11,:) ; loadFactorsNREngRot  =  loadFactorsMat(:,2) ; %# and the analytical value of the load factors is computed analyticLoadFactorsNREngRot = @(w) -2 * EA ...      ( (  (auxz+(-w)).^2 + auxx^2 - L^2 ) ./ (L * ( L + sqrt((auxz+(-w)).^2 + auxx^2) )) ) ...   .* (auxz+(-w)) ./ ( sqrt((auxz+(-w)).^2 + auxx^2) )  ;  %# %# %### Results verification %#––––––––– %# %#### numerical verification [ analyticLoadFactorsNREngRot( controlDispsNREngRot)' loadFactorsNREngRot ] difLoad = analyticLoadFactorsNREngRot( controlDispsNREngRot)' - loadFactorsNREngRot ; verifBoolean = ( norm( difLoad ) / norm( loadFactorsNREngRot ) ) <  1e-4  %#### Plots lw = 2.0 ; ms = 11 ; plotfontsize = 22 ; figure plot( controlDispsNREngRot, analyticLoadFactorsNREngRot( controlDispsNREngRot) ,'b-x' , 'linewidth', lw,'markersize',ms ) hold on, grid on plot( controlDispsNREngRot, loadFactorsNREngRot, 'k-o' , 'linewidth', lw,'markersize',ms ) labx = xlabel('Displacement');   laby = ylabel('lambda') ; legend( 'analytic', 'NR-RotEng', 'location','North') set(gca, 'linewidth', 1.2, 'fontsize', plotfontsize ) set(labx, 'FontSize', plotfontsize); set(laby, 'FontSize', plotfontsize) ; print('vonMisesTrussCheck.png','-dpng') %# %#```@raw html %#<img src=\"https://raw.githubusercontent.com/ONSAS/ONSASdocs/master/docs/src/tutorials/StaticVonMisesTruss/vonMisesTrussCheck.png\" alt=\"plot check\" width=\"500\"/> %#``` %#","category":"page"},{"location":"theory/prinTherWork/#Principle-of-Virtual-Thermal-Work","page":"Principle of Virtual Thermal Work","title":"Principle of Virtual Thermal Work","text":"","category":"section"},{"location":"theory/prinTherWork/#Variational-formulation-of-the-heat-flow-equation","page":"Principle of Virtual Thermal Work","title":"Variational formulation of the heat flow equation","text":"","category":"section"},{"location":"theory/prinTherWork/","page":"Principle of Virtual Thermal Work","title":"Principle of Virtual Thermal Work","text":"    int_Omega k nabla T cdot nabla delta T dV\n  + int_Omega rho c fracpartial Tpartial t delta T dV\n  =\n    int_Omega Q_h delta T d V\n  + int_partial Omega k nabla T cdot hatmathbfn delta T d S \n qquad forall delta T in tildemathcalT","category":"page"},{"location":"theory/prinTherWork/","page":"Principle of Virtual Thermal Work","title":"Principle of Virtual Thermal Work","text":"Considering the boundary conditions","category":"page"},{"location":"theory/prinTherWork/","page":"Principle of Virtual Thermal Work","title":"Principle of Virtual Thermal Work","text":"left\nbeginarraylr\nT(mathbfxt) = f_D(t)  texton Gamma_D \n-k fracpartial Tpartial n (mathbfxt) = f_N(mathbfxt)  texton  Gamma_N \n-k fracpartial Tpartial n (mathbfxt) = h left( T(mathbfxt)-T_infty(t) right)   texton  Gamma_R\nendarray\nright","category":"page"},{"location":"theory/prinTherWork/","page":"Principle of Virtual Thermal Work","title":"Principle of Virtual Thermal Work","text":"where h is the convection coefficient and T_infty(t) is the ambient temperature at time t.","category":"page"},{"location":"theory/prinTherWork/","page":"Principle of Virtual Thermal Work","title":"Principle of Virtual Thermal Work","text":"    int_Omega k nabla T cdot nabla delta T dV\n  + int_Omega rho c fracpartial Tpartial t delta T dV\n  + int_Gamma_R h T(mathbfxt) delta T d S \n  =\n    int_Omega Q_h delta T d V\n  + int_Gamma_N q_inp(mathbfxt)  delta T d S \n  + int_Gamma_R h T_infty(t) delta T d S \n\n qquad forall delta T in tildemathcalT","category":"page"},{"location":"theory/prinTherWork/","page":"Principle of Virtual Thermal Work","title":"Principle of Virtual Thermal Work","text":"where q_inp is the input heat flow q_inp = -f_N.","category":"page"},{"location":"theory/prinTherWork/#Finite-Elements","page":"Principle of Virtual Thermal Work","title":"Finite Elements","text":"","category":"section"},{"location":"theory/prinTherWork/","page":"Principle of Virtual Thermal Work","title":"Principle of Virtual Thermal Work","text":"mathbfK_diff^e = frac k^e A^eell^e \nleft\nbeginmatrix\n1  -1 \n-1  1\nendmatrix\nright","category":"page"},{"location":"theory/prinTherWork/","page":"Principle of Virtual Thermal Work","title":"Principle of Virtual Thermal Work","text":"mathbfC_intE^e = rho^e c^e A^e ell^e frac16 \nleft\nbeginmatrix\n2  1 \n1  2\nendmatrix\nright","category":"page"},{"location":"theory/numericalMethods/#Numerical-Methods","page":"Numerical Methods","title":"Numerical Methods","text":"","category":"section"},{"location":"theory/numericalMethods/#ArcLength-Method","page":"Numerical Methods","title":"ArcLength Method","text":"","category":"section"},{"location":"theory/numericalMethods/","page":"Numerical Methods","title":"Numerical Methods","text":"lambda^2 cdot left bardelta textbfu right^2 \n+\nlamda cdot left(  2( Delta textbfu + delta textbfu^* )^T delta textbfu  right)\n+\n left( (  left Delta textbfu delta textbfu^* left ) - r_arc^2 right)","category":"page"},{"location":"tutorials/SimplePendulum/simple_pendulum/#Simple-pendulum","page":"Simple pendulum","title":"Simple pendulum","text":"","category":"section"},{"location":"tutorials/SimplePendulum/simple_pendulum/#Model","page":"Simple pendulum","title":"Model","text":"","category":"section"},{"location":"tutorials/SimplePendulum/simple_pendulum/","page":"Simple pendulum","title":"Simple pendulum","text":"In this tutorial we study a simple pendulum. The model has one truss element. This model is taken from (Bathe,2014).","category":"page"},{"location":"tutorials/SimplePendulum/simple_pendulum/","page":"Simple pendulum","title":"Simple pendulum","text":"Parameter Value\nEs 10e11\nnu 0\nA 0.1\nl0 3.0443\nm 10\ng 9.81","category":"page"},{"location":"tutorials/SimplePendulum/simple_pendulum/#Result","page":"Simple pendulum","title":"Result","text":"","category":"section"},{"location":"tutorials/SimplePendulum/simple_pendulum/","page":"Simple pendulum","title":"Simple pendulum","text":"note: TO-DO\nAdd results.","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/#Heat-Analytic","page":"Heat Analytic","title":"Heat Analytic","text":"","category":"section"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"In this example a heat transfer problem with known analytical solution is presented and solved. The FEM solution is verified using the analytical solution.","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/#problem-description","page":"Heat Analytic","title":"problem description","text":"","category":"section"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"Let us consider the one-dimensional heat equation, partial_t T(x t) = alpha partial^2_xxT(x t) where alpha = k  rho c is assumed uniform in the domain 01 and constant. Q_h = 0 is also assumed. The boundary conditions are given by Dirichlet conditions at both boundaries for all times T(0t) = 0 and T(1t)=0. The initial condition is given by the following temperature distribution function:","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"T(x t=0) = phi(x) = sin pi x + frac12sin 3pi x","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"using Plots, LaTeXStrings\n\nϕ(x) = sin(π*x) + sin(3π*x)/2\n\nne = 50 # number of elements\nxdom = 0:1/ne:1\nT0 = ϕ.(xdom)\n\nplot(0:1e-3:1, ϕ, seriestype=:line, lab=L\"\\phi(x)\",\n     xlab=L\"x\", ylab=L\"T\", legend=:bottomright, title=\"Initial temperature profile\")\nplot!(xdom, T0, seriestype = :scatter, lab=L\"T(x=x_e, 0)\")\n#savefig(\"plot_initial_temperature.svg\")\n\nnothing","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"The analytic solution in this case is","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"T(x t) = e^- pi^2 alpha tsin pi x + frac12e^-(3pi)^2 alpha tsin 3pi xqquad 0 leq x leq 1 t geq 0","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/#Numerical-resolution","page":"Heat Analytic","title":"Numerical resolution","text":"","category":"section"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/#D-numerical-solution","page":"Heat Analytic","title":"1D numerical solution","text":"","category":"section"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"close all, clear all\naddpath( genpath( '../../src/')); % add ONSAS src functions","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"timeIncr  = 0.0001 ;   Tfinal    = 0.02   ;\nrho       = 1.     ;   cSpHe     = 1.     ;\nkCond     = 4      ;   L         = 1      ;\nArea      = 0.25   ;   nelem     = 20     ;\nTdiri     = 0      ;   nPlots = 4 ;","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"\ndiriDofs = [ 1 nelem+1 ];  robiDofs = [] ;\n\nproblemName     = 'Heat1DAnalytic' ;\ninitialTempFunc = 'myInitialTemp' ;\nambTempFuncName = 'myAmbTemp'     ;\n\nndivs     = [ nelem  ];\nhConv = []; Tamb = [];\nqInpLeft = []; qInpRight = [];\nTdiri = 0 ;\n\n[Ts, NodesCoord, times ] = HeatFEM( ...\n  timeIncr, Tfinal, ...\n  [rho, cSpHe, kCond], ...\n  [ 1 L Area ], ...\n  ndivs, ...\n  hConv, diriDofs, robiDofs, ambTempFuncName, qInpLeft, qInpRight, Tdiri, ...\n  nPlots, problemName, initialTempFunc, [], [], [], []);\n\n","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/#D-numerical-solution-2","page":"Heat Analytic","title":"3D numerical solution","text":"","category":"section"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"\ntimeIncr  = 0.0001 ; Tfinal    = 0.01   ;\nLx        = 1      ; Ly        = .5     ;\nLz        = .5     ; Tdiri     = 0      ;\n\nassert( Area == (Ly*Lz) ) ;\n\ndiriDofs = []; robiDofs = [] ;\n\nnPlots = inf ;\n\ninitialTempFunc = 'myInitialTemp' ;\n\nndivs     = [ 10 2 2 ];\n\nhConv = []; Tamb = [];\nqInpLeft = []; qInpRight = [];\n\nTdiri = 0 ; qInp = 0;\n\ndiriFaces = [ Tdiri 1 2 ];\nneumFaces = [ qInp  3 4 5 6 ] ;\nrobiFaces = [  ] ;\n\n[Ts3D, NodesCoord, times ] = HeatFEM( ...\n  timeIncr, Tfinal, ...\n  [rho, cSpHe, kCond], ...\n  [ 2 Lx Ly Lz ], ...\n  ndivs, ...\n  hConv, diriDofs, robiDofs, Tamb, qInpLeft, qInpRight, Tdiri, ...\n  nPlots, problemName, initialTempFunc, [], ...\n  diriFaces, neumFaces, robiFaces  );\n\n\n\n\n\n","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/#solution-verification","page":"Heat Analytic","title":"solution verification","text":"","category":"section"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"analytical solution computation","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"% analytic solution computation\nindplot = round(nelem/2) ;\nxsAnly = NodesCoord(indplot) ;\nalpha  = kCond / ( rho * cSpHe ) ;\ntanali =  exp( -(  pi)^2 * alpha * times ) *       sin(     pi * xsAnly) ...\n        + exp( -(3*pi)^2 * alpha * times ) * 0.5 * sin( 3 * pi * xsAnly ) ;","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"plot settings ``` figure, grid on, hold on MS = 18 ; LW = 1.5 ;","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"ntimes = length(times); indsMarkers = floor( linspace(1,ntimes, 6)' ) ;","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"plot( times(indsMarkers(1)), Ts(indplot,indsMarkers(1)), 'b-x',  'markersize', MS,'linewidth',LW ) plot( times(indsMarkers(1)), tanali(indsMarkers(1)), 'r-o',  'markersize', MS,'linewidth',LW )","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"% numerical solution plot","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"plot( times, Ts(indplot,:), 'b',  'markersize', MS,'linewidth',LW ) plot( times(indsMarkers), Ts(indplot,indsMarkers), 'x',  'markersize', MS,'linewidth',LW )","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"% analytic solution plot plot( times, tanali, 'r',  'markersize', MS,'linewidth',LW ) plot( times(indsMarkers), tanali(indsMarkers), 'o',  'markersize', MS,'linewidth',LW ) xlabel('t'), ylabel('Temp')","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"legend('FEM1D','analytic')","category":"page"},{"location":"tutorials/HeatAnalytic/HeatAnalytic/","page":"Heat Analytic","title":"Heat Analytic","text":"print( [ './pngs/' problemName '.png'],'-dpng' ) % –––––––––––––––––","category":"page"},{"location":"cantileverBeam/#Uniform-curvature-cantilever-beam","page":"Cantilever Beam","title":"Uniform curvature cantilever beam","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"In this tutorial, the Uniform curvature cantilever example and its resolution using ONSAS are described. The aim of this example is to validate the static co-rotational 3D beam implementation by comparing the results provided by ONSAS with the analytical solution.  The Octave script of this example is available at this url.","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"The problem consists in a beam, with one free end (right) submitted to a nodal moment M, and the other end (left) constrained (welded), as it is shown in the figure.","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/tutorials/CantileverBeam/cantileverBeam.svg\" alt=\"structure diagram\" width=\"500\"/>","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"Before defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar geometry and material parameters are defined.","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"close all, clear all ;\n% add path\naddpath( [ pwd '/../../src'] );\n% material scalar parameters\nE = 200e9 ;  nu = 0.3 ;\n% geometrical scalar parameters\nl = 10 ; ty = .1 ;  tz = .1 ;\n% the number of elements of the mesh\nnumElements = 10 ;","category":"page"},{"location":"cantileverBeam/#MEBI-parameters","page":"Cantilever Beam","title":"MEBI parameters","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"The modelling of the structure begins with the definition of the Material-Element-BoundaryConditions-InitialConditions (MEBI) parameters.","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"","category":"page"},{"location":"cantileverBeam/#materials","page":"Cantilever Beam","title":"materials","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"Since the example contains only one rod the fields of the materials struct will have only one entry. Although, it is considered constitutive behavior according to the SaintVenantKirchhoff law:","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"materials.hyperElasModel  = { '1DrotEngStrain'} ;\nmaterials.hyperElasParams = { [ E nu ] } ;","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"The density is not defined, therefore it is considered as zero (default), then no inertial effects are considered (static analysis).","category":"page"},{"location":"cantileverBeam/#elements","page":"Cantilever Beam","title":"elements","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"Two different types of elements are considered, node and beam. The nodes will be assigned in the first entry (index 1) and the beam at the index 2. The elemType field is then:","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"elements.elemType = { 'node','frame' } ;","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"for the geometries, the node has not geometry to assign (empty array), and the truss elements will be set as a rectangular-cross section with t_y and t_z cross-section dimensions in y and z directions, then the elemTypeGeometry field is:","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"elements.elemTypeGeometry = { [], [2 ty tz ] };\nelements.elemTypeParams = { [], 1 };","category":"page"},{"location":"cantileverBeam/#boundaryConds","page":"Cantilever Beam","title":"boundaryConds","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"The elements are submitted to two different BC settings. The first BC corresponds to a welded condition (all 6 dofs set to zero), and the second corresponds to an incremental nodal moment, where the target load produces a circular form of the deformed beam.  The scalar values of inertia I_z is computed.","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"Iy = ty*tz^3/12 ;\nboundaryConds.loadsCoordSys = { []        ; 'global'   } ;\nboundaryConds.loadsTimeFact = { []        ; @(t) E*Iy*2*pi/l *t } ;\nboundaryConds.loadsBaseVals = { []        ; [ 0 0 0 -1 0 0 ] } ;\nboundaryConds.imposDispDofs = { [ 1 2 3 4 5 6 ] ; []         } ;\nboundaryConds.imposDispVals = { [ 0 0 0 0 0 0 ] ; []         } ;","category":"page"},{"location":"cantileverBeam/#initial-Conditions","page":"Cantilever Beam","title":"initial Conditions","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"homogeneous initial conditions are considered, then an empty struct is set:","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"initialConds                = struct() ;","category":"page"},{"location":"cantileverBeam/#mesh-parameters","page":"Cantilever Beam","title":"mesh parameters","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"The coordinates of the nodes of the mesh are given by the matrix:","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"mesh.nodesCoords = [ (0:(numElements))'*l/numElements  zeros(numElements+1,2) ] ;","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"The connectivity is introduced using the conecCell. Each entry of the cell contains a vector with the four indexes of the MEBI parameters, followed by the indexes of the nodes of the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"mesh.conecCell = { } ;","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"then the first two nodes are defined, both with material zero (since nodes dont have material), the first element type (the first entry of the cells of the elements struct), and the first entry of the cells of the boundary conditions struct. No non-homogeneous initial condition is considered (then zero is used) and finally the node is included.","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"mesh.conecCell{ 1, 1 } = [ 0 1 1 0  1   ] ;","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"the following case only differs in the boundary condition and the node number","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"mesh.conecCell{ 2, 1 } = [ 0 1 2 0  numElements+1 ] ;","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"the beam elements are formed by the first material, the second type of element, and no boundary conditions are applied to any element.","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"for i=1:numElements,\n  mesh.conecCell{ i+2,1 } = [ 1 2 0 0  i i+1 ] ;\nend","category":"page"},{"location":"cantileverBeam/#analysisSettings","page":"Cantilever Beam","title":"analysisSettings","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"analysisSettings.methodName    = 'newtonRaphson' ;\nanalysisSettings.deltaT        =   0.1  ;\nanalysisSettings.finalTime     =   1.0  ;\nanalysisSettings.stopTolDeltau =   1e-6 ;\nanalysisSettings.stopTolForces =   1e-6 ;\nanalysisSettings.stopTolIts    =   10   ;","category":"page"},{"location":"cantileverBeam/#otherParams","page":"Cantilever Beam","title":"otherParams","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"otherParams.problemName = 'uniformCurvatureCantilever';\notherParams.controlDofs = [ numElements+1  4 ] ;","category":"page"},{"location":"cantileverBeam/#Analysis-case-1:-NR-with-Rotated-Eng-Strain","page":"Cantilever Beam","title":"Analysis case 1: NR with Rotated Eng Strain","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"In the first case ONSAS is run and the solution at the dof (angle of node B) of interest is stored:","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"[matUs, loadFactorsMat] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;\n","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"the control dof to verificate the solution is the node angle B, this corresponds to the following dof number:","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"angleControlDof      = (numElements+1)*6 - 2;\ncontrolDispsNREngRot =  -matUs(angleControlDof,:) ;\nloadFactorsNREngRot  =  loadFactorsMat(:,2) ;","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"and the analytical value of the load factors is computed","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"analyticLoadFactorsNREngRot = @(w) E * Iy * w / l ;\n","category":"page"},{"location":"cantileverBeam/#Results-verification","page":"Cantilever Beam","title":"Results verification","text":"","category":"section"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"verifBoolean = norm( analyticLoadFactorsNREngRot( controlDispsNREngRot) ...\n                     - loadFactorsNREngRot' )  ...\n                    < ( norm( analyticLoadFactorsNREngRot( controlDispsNREngRot) ) * 1e-4 )","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"lw = 2.0 ; ms = 11 ; plotfontsize = 22 ;\nfigure\nplot( controlDispsNREngRot, analyticLoadFactorsNREngRot( controlDispsNREngRot) ,'b-x' , 'linewidth', lw,'markersize',ms )\nhold on, grid on\nplot( controlDispsNREngRot, loadFactorsNREngRot, 'k-o' , 'linewidth', lw,'markersize',ms )\nlabx = xlabel('Displacement');   laby = ylabel('$\\lambda$') ;\nlegend('analytic','NR-RotEng','location','North')\nset(gca, 'linewidth', 1.2, 'fontsize', plotfontsize )\nset(labx, 'FontSize', plotfontsize); set(laby, 'FontSize', plotfontsize) ;\nprint('verifCantileverBeam.png','-dpng')","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/tutorials/CantileverBeam/verifCantileverBeam.png\" alt=\"plot check\" width=\"500\"/>","category":"page"},{"location":"cantileverBeam/","page":"Cantilever Beam","title":"Cantilever Beam","text":"``` verifBoolean = norm( analyticLoadFactorsNREngRot( controlDispsNREngRot) - loadFactorsNREngRot' )  < ( norm( analyticLoadFactorsNREngRot( controlDispsNREngRot) ) * 1e-4 )","category":"page"},{"location":"howtouse/functions/#list-of-ONSAS.m-functions","page":"list of ONSAS.m functions","title":"list of ONSAS.m functions","text":"","category":"section"},{"location":"howtouse/functions/","page":"list of ONSAS.m functions","title":"list of ONSAS.m functions","text":"This is a list of all the .m functions of the ONSAS Octave implementation:","category":"page"},{"location":"howtouse/functions/","page":"list of ONSAS.m functions","title":"list of ONSAS.m functions","text":"checkOrSetDefault.m\ncrossSectionProps.m\nelem2NodalLoads.m\nmyCell2Mat.m\nnodes2dofs.m\nONSAS.m","category":"page"},{"location":"howtouse/creatingModels/#Creating-structural-models","page":"Creating Models","title":"Creating structural models","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"The data and properties of each structural model are defined through a set of definitions in a .m script. These properties are stored in struct data structures. The following structs must be defined and provided as input to the ONSAS function in this order:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"materials\nelements\nboundaryConds\ninitialConds\nmesh\nnumericalMethod\notherParams","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"Each struct has its own fields with specific names, used to store each corresponding property or information. Each field is obtained or assiged using structName.fieldName. A description of each struct and its fields follows at next.","category":"page"},{"location":"howtouse/creatingModels/#The-materials-struct","page":"Creating Models","title":"The materials struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"The materials struct contains the information of the material behavior considered for each element.","category":"page"},{"location":"howtouse/creatingModels/#material.hyperElasModel","page":"Creating Models","title":"material.hyperElasModel","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"This is a cell array with the string-names of the material models used, the options for these names are:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"'linearElastic': for linear behaviour in small strains and displacements. The scalar parameters of this model are p_1=E the Young modulus and p_2=nu the Poisson's ratio.\n'SVK': for a Saint-Venant-Kirchhoff material where the parameters p_1 and p_2 are the Lamé parameters and textbfE is the Green-Lagrange strain tensor, with the strain-energy density function given by","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"Psi( textbfE ) = fracp_12 tr(textbfE)^2 + p_2 tr(textbfE^2)\nquad\np_1 = frac E nu  (1+nu) (1-2nu) \nquad\np_2 = frac E  2 (1+nu) ","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"'NHC': for a Neo-Hookean compressible material","category":"page"},{"location":"howtouse/creatingModels/#materials.hyperElasParams","page":"Creating Models","title":"materials.hyperElasParams","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"A cell structure with vectors with the material properties of each material used in the model. The i-th entry of the cell, contains a vector like this:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":" p_1 dots p_n_P ","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"where n_P is the number of parameters of the constitutive model and mathbfp is the vector of constitutive parameters.","category":"page"},{"location":"howtouse/creatingModels/#material.density","page":"Creating Models","title":"material.density","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"This is a cell with the scalar values of the densities of the materials used in the model.","category":"page"},{"location":"howtouse/creatingModels/#The-elements-struct","page":"Creating Models","title":"The elements struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"The elements struct contains the information about the type of finite elements used and their corresponding parameters.","category":"page"},{"location":"howtouse/creatingModels/#elements.elemType","page":"Creating Models","title":"elements.elemType","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell structure with the string-names of the elements used: node, truss, frame, triangle or tetrahedron. Other auxiliar types such as edge are also available","category":"page"},{"location":"howtouse/creatingModels/#elements.elemTypeParams","page":"Creating Models","title":"elements.elemTypeParams","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell structure with auxiliar params information, required for some element types:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"triangle vector with parameters, the first parameter is an integer indicating if plane stress (1) or plane strain (2) case is considered.","category":"page"},{"location":"howtouse/creatingModels/#elements.elemTypeGeometry","page":"Creating Models","title":"elements.elemTypeGeometry","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell structure with the information of the geometry of the element.","category":"page"},{"location":"howtouse/creatingModels/#D-elements","page":"Creating Models","title":"1D elements","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"For truss or frame elements a vector with the cross-section properties is required:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":" crossSectionType  crossSectionParam_1 dots crossSectionParam_n","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"with n being the number of parameters of the cross section type, and crossSectionType a paramter setting the type of cross section. As follow:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"general sections areas and inertias are provided\nrectangular sections: thicknesses t_y and t_z are provided\ncircular sections: diameter is provided.","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"See the crossSectionProps.m function for more details.","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"For edge elements the thickness is expected (for 2D load computations).","category":"page"},{"location":"howtouse/creatingModels/#D-elements-2","page":"Creating Models","title":"2D elements","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"For 2D elements such as triangle the thickness is expected to be introduced. The elementtype  ","category":"page"},{"location":"howtouse/creatingModels/#The-boundaryConds-struct","page":"Creating Models","title":"The boundaryConds struct","text":"","category":"section"},{"location":"howtouse/creatingModels/#boundaryConds.loadsCoordSys","page":"Creating Models","title":"boundaryConds.loadsCoordSys","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell containing the coordinates system for the loads applied in each BC, each entry should be a 'global' string or a 'local', or an empty array if no load is applied in that BC setting [].","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.loadsTimeFact","page":"Creating Models","title":"boundaryConds.loadsTimeFact","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with the inline function definitions of load factors of the loads applied of an empty array.","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.loadsBaseVals","page":"Creating Models","title":"boundaryConds.loadsBaseVals","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with the (row) vector of the components of the load case","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":" f_x   m_x  f_y  m_y  f_z  m_z ","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"where f_i are the components of forces and m_i are the moments. Both forces or moments are considered per unit of length in the case of truss/frame/edge elements, or per unit of area in the case of triangle.","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.userLoadsFileName","page":"Creating Models","title":"boundaryConds.userLoadsFileName","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with filenames of .m function file provided by the user that can be used to apply other forces.","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.imposDispDofs","page":"Creating Models","title":"boundaryConds.imposDispDofs","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with vectors of the local degrees of freedom imposed (integers from 1 to 6)","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.imposDispVals","page":"Creating Models","title":"boundaryConds.imposDispVals","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with vectors of the values of displacements imposed.","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.springsDofs","page":"Creating Models","title":"boundaryConds.springsDofs","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with vectors of the local degrees of freedom with springs (integers from 1 to 6)","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.springsVals","page":"Creating Models","title":"boundaryConds.springsVals","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with vectors of the values of the springs stiffnesses.","category":"page"},{"location":"howtouse/creatingModels/#The-initialConds-struct","page":"Creating Models","title":"The initialConds struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"It initial conditions are homogeneous, then an empty struct should be defined initialConds = struct() ;.","category":"page"},{"location":"howtouse/creatingModels/#initialConds.nonHomogeneousInitialCondU0","page":"Creating Models","title":"initialConds.nonHomogeneousInitialCondU0","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"matrix to set  the value of displacements at the time step t=0. [default: []]","category":"page"},{"location":"howtouse/creatingModels/#initialConds.nonHomogeneousInitialCondUdot0","page":"Creating Models","title":"initialConds.nonHomogeneousInitialCondUdot0","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"matrix to prescribe the value of velocities at the time step t=0. [default: []]","category":"page"},{"location":"howtouse/creatingModels/#The-mesh-struct","page":"Creating Models","title":"The mesh struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"The mesh struct contains the finite element mesh information.","category":"page"},{"location":"howtouse/creatingModels/#mesh.nodesCoords","page":"Creating Models","title":"mesh.nodesCoords","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"matrix with the coordinates of all the nodes of the mesh. The i-th row contains the three coordinates of the node i: x_i   y_i  z_i,","category":"page"},{"location":"howtouse/creatingModels/#mesh.conecCell","page":"Creating Models","title":"mesh.conecCell","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell array with the elements and node-connectivity information. The i1 entry contains the vector with the MEBI (Material, Element, boundaryConds and initialConds) indexes and the nodes of the i-th element. The structure of the vector at each entry of the cell is:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"  materialInd  elementInd  boundaryCondInd  initialCondInd  node_1 dots node_n ","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"where the five indexes are natural numbers and n is the number of nodes required by the type of element. If noproperty is assigned the 0 index can be used, for instance, nodes used to introduced loads should be defined with materialIndex = 0.","category":"page"},{"location":"howtouse/creatingModels/#The-analysisSettings-struct","page":"Creating Models","title":"The analysisSettings struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"This struct contains the parameters required to apply the numerical method for the resolution of the nonlinear equations:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"methodName: string with the name of the method used: 'newtonRaphson','arcLength','newmark','alphaHHT'.\nstopTolDeltau: float with tolerance for convergence in relative norm of displacements increment\nstopTolForces: float with tolerance for convergence in relative norm of residual loads\nstopTolIts: integer with maximum number of iterations per time step\ndeltaT: time step\nfinalTime: final time of simulation\nincremArcLen: with of cylinder for arcLength method\ndeltaNM: delta parameter of newmark method\nalphaNM: alpha parameter of newmark method\nalphaHHT: alpha parameter of alpha-HHT method","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"another additional optional parameters are:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"nodalDispDamping: scalar value of linear external viscous damping for the displacements degrees of freedom [default: 0]\niniMatUs: a matrix with initial solutions for each time step.","category":"page"},{"location":"howtouse/creatingModels/#The-otherParams-struct","page":"Creating Models","title":"The otherParams struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"problemName: string with the name of the problem, to be used in outputs.\nplotsFormat: strint indicating the format of the output. Use 'vtk' for vtk output.\ncontrolDofs: matrix with information of the degrees of freedom to compute and control. Each row should contain this form: [ node localdof ].\nstoreBoolean: boolean to store the results of the current iteration such as the displacements, tangent matrices, normal forces and stresses. [default: 1]","category":"page"},{"location":"howtouse/install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"howtouse/install/#Running-ONSAS.m","page":"Installation","title":"Running ONSAS.m","text":"","category":"section"},{"location":"howtouse/install/","page":"Installation","title":"Installation","text":"The user should follow these steps to install and run ONSAS:","category":"page"},{"location":"howtouse/install/","page":"Installation","title":"Installation","text":"Download and install the latest version of GNU-Octave.\nDownload the zip file of the latest ONSAS release from these site.\nOpen GNU-Octave and run one of the example scripts from the examples folder (or create yours!).","category":"page"},{"location":"howtouse/install/#Visualizing-results","page":"Installation","title":"Visualizing results","text":"","category":"section"},{"location":"howtouse/install/","page":"Installation","title":"Installation","text":"You can process the outputs using Octave, however, the open-source software ParaView can be used to visualize the results produced by ONSAS.","category":"page"},{"location":"howtouse/install/#Generation-of-geometries/meshes","page":"Installation","title":"Generation of geometries/meshes","text":"","category":"section"},{"location":"howtouse/install/","page":"Installation","title":"Installation","text":"The user can provide the geometry of the structure using two optional formats: .msh or .dxf.  GMSH is an open-source tool that allows to generate high-quality meshes. The dxf files can be used using any CAD tool.","category":"page"},{"location":"theory/references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"theory/references/","page":"References","title":"References","text":"(Bathe, 2014) Klaus-Jurgen Bathe.  Finite Element Procedures . 2014.\n(Bazzano and Pérez Zerpa, 2017) J. B. Bazzano and J. Perez Zerpa.  Introducción al Análisis No Lineal de Estructuras. 2017.\n(Holzapfel, 2000) Nonlinear Solid Mechanics, A continuum approach for Engineering, 2000, Wiley.","category":"page"},{"location":"staticVonMisesTruss/#Static-Von-Mises-Truss-example","page":"Static Von-Mises Truss","title":"Static Von Mises Truss example","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"In this tutorial, the Static Von Mises Truss example and its resolutions using ONSAS are described. The aim of this example is to validate the Newton-Raphson method implementation by comparing the results provided by ONSAS with the analytical solution. The Octave script of this example is available at this url.","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The structural model is formed by two truss elements with length L as it is shown in the figure, with the node 2 submitted to a nodal load P and restrained to move in the x-z plane and nodes 1 and 3 fixed.","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/tutorials/StaticVonMisesTruss/vonMisesTruss.svg\" alt=\"structure diagram\" width=\"500\"/>","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"Before defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar auxiliar parameters are defined.","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"close all, clear all ;\naddpath( genpath( [ pwd '/../../src'] ) );\nE = 210e9 ;  A = 2.5e-3 ; ang1 = 65 ; L = 2 ; nu = 0 ;\n% x and z coordinates\nauxx = cos( ang1*pi/180 ) * L ;  auxz = sin( ang1*pi/180 ) * L ;","category":"page"},{"location":"staticVonMisesTruss/#MEBI-parameters","page":"Static Von-Mises Truss","title":"MEBI parameters","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The modelling of the structure begins with the definition of the Material-Element-BoundaryConditions-InitialConditions (MEBI) parameters.","category":"page"},{"location":"staticVonMisesTruss/#materials","page":"Static Von-Mises Truss","title":"materials","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"Since both bars are formed by the same material all the fields of the materials struct will have only one entry. contains only one vector. The constitutive behavior is the SaintVenantKirchhoff:","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"materials.hyperElasModel  = { '1DrotEngStrain'} ;\nmaterials.hyperElasParams = { [ E nu ] } ;","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"and the parameters of this model are the Young modulus and Poisson ratio.","category":"page"},{"location":"staticVonMisesTruss/#elements","page":"Static Von-Mises Truss","title":"elements","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"Two different types of elements are considered, node and truss. The nodes will be assigned in the first entry (index 1) and the truss at the index 2. The elemType field is then:","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"elements.elemType = { 'node','truss' } ;","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"for the geometries, the node has no geometry to assign (empty array), and the truss elements will be set as a square-cross section, then the elemTypeGeometry field is:","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"elements.elemTypeGeometry = { [], [2 sqrt(A) sqrt(A) ] };\nelements.elemTypeParams = { [], 1 };","category":"page"},{"location":"staticVonMisesTruss/#boundaryConds","page":"Static Von-Mises Truss","title":"boundaryConds","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The elements are submitted to two different BC settings. The nodes 1 and 3 are fixed without applied loads (first BC), and node 2 has a constraint in displacement and an applied load (second BC). The load factor function of the second BC is set so that the target load 1.5e8 is reached at 1 second. The density is set to zero, then no inertial effects are considered.","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"boundaryConds.loadsCoordSys = { []        ; 'global'   } ;\nboundaryConds.loadsTimeFact = { []        ; @(t) 1.5e8*t     } ;\nboundaryConds.loadsBaseVals = { []        ; [ 0 0 0 0 -1 0 ] } ;\nboundaryConds.imposDispDofs = { [ 1 3 5 ] ; 3          } ;\nboundaryConds.imposDispVals = { [ 0 0 0 ] ; 0          } ;","category":"page"},{"location":"staticVonMisesTruss/#initial-Conditions","page":"Static Von-Mises Truss","title":"initial Conditions","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"homogeneous initial conditions are considered, then an empty struct is set:","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"initialConds                = struct() ;","category":"page"},{"location":"staticVonMisesTruss/#mesh-parameters","page":"Static Von-Mises Truss","title":"mesh parameters","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The coordinates of the nodes of the mesh are given by the matrix:","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"mesh.nodesCoords = [      0  0     0  ; ...\n                       auxx  0  auxz  ; ...\n                     2*auxx  0     0  ] ;","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The connectivity is introduced using the conecCell. Each entry of the cell contains a vector with the four indexes of the MEBI parameters, followed by the indexes of the nodes of the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"mesh.conecCell = { } ;","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"then the first two nodes are defined, both with material zero (since nodes dont have material), the first element type (the first entry of the cells of the elements struct), and the first entry of the cells of the boundary conditions struct. No non-homogeneous initial condition is considered (then zero is used) and finally the node is included.","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"mesh.conecCell{ 1, 1 } = [ 0 1 1 0  1   ] ;\nmesh.conecCell{ 2, 1 } = [ 0 1 1 0  3   ] ;","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"the following case only differs in the boundary condition","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"mesh.conecCell{ 3, 1 } = [ 0 1 2 0  2   ] ;","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"the truss elements are formed by the first material, the second type of element, and no boundary condition is applied.","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"mesh.conecCell{ 4, 1 } = [ 1 2 0 0  1 2 ] ;\nmesh.conecCell{ 5, 1 } = [ 1 2 0 0  2 3 ] ;","category":"page"},{"location":"staticVonMisesTruss/#analysisSettings","page":"Static Von-Mises Truss","title":"analysisSettings","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"analysisSettings.methodName    = 'newtonRaphson' ;\nanalysisSettings.deltaT        = 0.1 ;\nanalysisSettings.finalTime     =   1 ;\nanalysisSettings.stopTolDeltau =   1e-6 ;\nanalysisSettings.stopTolForces =   1e-6 ;\nanalysisSettings.stopTolIts    =   10 ;\nanalysisSettings.finalTime     =   1 ;","category":"page"},{"location":"staticVonMisesTruss/#otherParams","page":"Static Von-Mises Truss","title":"otherParams","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"otherParams.problemName = 'staticVonMisesTruss_NR';\notherParams.controlDofs = [2 5 ];","category":"page"},{"location":"staticVonMisesTruss/#Analysis-case-1:-NR-with-Rotated-Eng-Strain","page":"Static Von-Mises Truss","title":"Analysis case 1: NR with Rotated Eng Strain","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"In the first case ONSAS is run and the solution at the dof of interest is stored .","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"[matUs, loadFactorsMat] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;\ncontrolDispsNREngRot =  -matUs(11,:) ;\nloadFactorsNREngRot  =  loadFactorsMat(:,2) ;","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"and the analytical value of the load factors is computed","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"analyticLoadFactorsNREngRot = @(w) -2 * E*A* ...\n     ( (  (auxz+(-w)).^2 + auxx^2 - L^2 ) ./ (L * ( L + sqrt((auxz+(-w)).^2 + auxx^2) )) ) ...\n  .* (auxz+(-w)) ./ ( sqrt((auxz+(-w)).^2 + auxx^2) )  ;","category":"page"},{"location":"staticVonMisesTruss/#Results-verification","page":"Static Von-Mises Truss","title":"Results verification","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"","category":"page"},{"location":"staticVonMisesTruss/#numerical-verification","page":"Static Von-Mises Truss","title":"numerical verification","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"[ analyticLoadFactorsNREngRot( controlDispsNREngRot)' loadFactorsNREngRot ]\ndifLoad = analyticLoadFactorsNREngRot( controlDispsNREngRot)' - loadFactorsNREngRot ;\nverifBoolean = ( norm( difLoad ) / norm( loadFactorsNREngRot ) ) <  1e-4","category":"page"},{"location":"staticVonMisesTruss/#Plots","page":"Static Von-Mises Truss","title":"Plots","text":"","category":"section"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"lw = 2.0 ; ms = 11 ; plotfontsize = 22 ;\nfigure\nplot( controlDispsNREngRot, analyticLoadFactorsNREngRot( controlDispsNREngRot) ,'b-x' , 'linewidth', lw,'markersize',ms )\nhold on, grid on\nplot( controlDispsNREngRot, loadFactorsNREngRot, 'k-o' , 'linewidth', lw,'markersize',ms )\nlabx = xlabel('Displacement');   laby = ylabel('$\\lambda$') ;\nlegend( 'analytic', 'NR-RotEng', 'location','North')\nset(gca, 'linewidth', 1.2, 'fontsize', plotfontsize )\nset(labx, 'FontSize', plotfontsize); set(laby, 'FontSize', plotfontsize) ;\nprint('vonMisesTrussCheck.png','-dpng')","category":"page"},{"location":"staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/tutorials/StaticVonMisesTruss/vonMisesTrussCheck.png\" alt=\"plot check\" width=\"500\"/>","category":"page"},{"location":"theory/prinMechWork/#Principle-of-Virtual-Mechanical-Work","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"","category":"section"},{"location":"theory/prinMechWork/#Variational-formulation-of-the-principle","page":"Principle of Virtual Mechanical Work","title":"Variational formulation of the principle","text":"","category":"section"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"ONSAS can be used to solve the set of nonlynear equations given by the Principle of Virtual Work (PVW). The PVW can be defined in terms of the following set of nonlinear equations:","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"left(\n     mathbff_mas(mathbfu_t dotmathbfu_t ddotmathbfu_t)\n  +  mathbff_vis(dotmathbfu_t)\n  +  mathbff_int(mathbfu_t)\n  -  mathbff_ext(t)\nright) cdot delta mathbfu\n=\n0 qquad forall delta mathbfu in tildemathcalU","category":"page"},{"location":"theory/prinMechWork/#Solid-Elements-Implementation","page":"Principle of Virtual Mechanical Work","title":"Solid Elements Implementation","text":"","category":"section"},{"location":"theory/prinMechWork/#Tetrahedron-Solid-Element","page":"Principle of Virtual Mechanical Work","title":"Tetrahedron Solid Element","text":"","category":"section"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"The tetrahedron element considered is a four-node linear element. The isoparametric coordinates reference element is shown in the following figure","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"(Image: )","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"and the linear shape functions are given by","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"N_1(xi) = xi_1 quad\nN_2(xi) = 1-xi_1-xi_2-xi_3 quad\nN_3(xi) = xi_3 quad\nN_4(xi) = xi_2","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"The functions can be expressed in vector form","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"  textbf N  =\n  left\nbeginmatrix\nN_1 \nN_2 \nN_3 \nN_4\nendmatrix\n  right","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"and the linear interpolation of the coordinates of any point within an element can be written as","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"textbfX = eleCoordMat  textbfN(xi)","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"where eleCoordMat is a matrix with the reference configuration coordinates (or material coordinates) of the nodes:","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"eleCoordMat =\nleft\nbeginmatrix\nX_11    X_12  X_13  X_14 \nX_21    X_22  X_23  X_24 \nX_31    X_32  X_33  X_34 \nendmatrix\nright","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"where X_ij represents the coordinate in the i-th dimension of the j-th node.","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"The displacements gradient tensor is defined as","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"  textbf H  =\n    frac partial textbf u  \n\t  partial textbf X  \n\t qquad\n  H_ij =  frac partial u_i   partial X_j ","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"and using the displacement interpolation can be written in matrix form as","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"textbf H  = eleDispsMat  fracpartial textbfN partial textbfX","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"The material-isoparametric coordinates relation is given by:","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"textbfX = eleCoordMat   textbf N (xi)","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"and using the chain rule we obtain:","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"fracpartial textbfN partial textbfX =\nfracpartial textbfN partial xi   fracpartial xi  partial textbfX ","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"Then using the inverse theorem we obtain:","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"fracpartial xi partial textbfX = left( eleCoordMat   fracpartial textbfN partial xi  right)^-1","category":"page"},{"location":"theory/prinMechWork/","page":"Principle of Virtual Mechanical Work","title":"Principle of Virtual Mechanical Work","text":"nabla textbfu = eleDispsMat  left( eleCoordMat   fracpartial textbfN partial xi  right)^-1","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<a href=\"https://gitter.im/onsas_/community?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\"><img src=\"https://badges.gitter.im/onsas_/community.svg\" alt=\"Join the chat at https://gitter.im/onsas_/community\">\n</a>","category":"page"},{"location":"#What-is-ONSAS?","page":"Home","title":"What is ONSAS?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ONSAS is an Open Nonlinear Structural Analysis Solver. It consists in a set of implementations of different numerical methods for static/dynamic and linear/non-linear analysis of structures. The first version was developed for educational purposes and published in a Structural Analysis handbook.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently different implementations and tools aimed for diverse applications are under development. The most mature is ONSAS.m, a GNU-Octave implementation of the solver, whose user guide is described in this documentation.","category":"page"},{"location":"#What-can-ONSAS-be-used-for?","page":"Home","title":"What can ONSAS be used for?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The current version allows to perform dynamic/static nonlinear analyses of beam/truss/solid 3D structures. A reduced list of features is listed at next:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Elements 2-node truss, 2-node Bernoulli frame, 4-node tetrahedron.\nStatic analysis methods Newton-Raphson Method and Cylindrical Arc-Length Method (to be fixed!).\nDynamic analysis methods Newmark Method and alpha-HHT.\nLoads nodal loads, time-history user-defined loading program.","category":"page"},{"location":"#Some-examples","page":"Home","title":"Some examples","text":"","category":"section"},{"location":"#A-wind-turbine-model","page":"Home","title":"A wind turbine model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://github.com/ONSAS/ONSAS_docs/blob/master/gifs/wind.gif?raw=true\" alt=\"wind turbine animation\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"wind turbine animation","category":"page"},{"location":"#A-tower-model","page":"Home","title":"A tower model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://github.com/ONSAS/ONSAS_docs/blob/master/gifs/tower.gif?raw=true\" alt=\"tower animation\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"tower","category":"page"},{"location":"#A-uniaxial-extension-test","page":"Home","title":"A uniaxial extension test","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://github.com/ONSAS/ONSAS_docs/blob/master/gifs/uniaxial.gif?raw=true\" alt=\"uniaxial animation\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"uniaxial animation","category":"page"},{"location":"#A-beam/truss-pendulum","page":"Home","title":"A beam/truss pendulum","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://raw.githubusercontent.com/mvanzulli/Tex_CorrotationalDynamicTL_TesisMV/main/Presentacion/Videos/3.gif\" alt=\"beam truss pendulum\">","category":"page"},{"location":"#A-chain-model","page":"Home","title":"A chain model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://user-images.githubusercontent.com/42485529/90902313-a6bf8d80-e3a2-11ea-8369-a9be639552f9.gif?raw=true\" alt=\"chain animation\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"chain","category":"page"},{"location":"#A-transmission-line-tower-model","page":"Home","title":"A transmission line tower model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://raw.githubusercontent.com/mvanzulli/Tex_CorrotationalDynamicTL_TesisMV/main/Presentacion/Videos/4.gif\" alt=\"transmission line\">","category":"page"},{"location":"#Contributors-and-License","page":"Home","title":"Contributors and License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code is distributed under a GNU-GPL 3.0 license.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following authors collaborated in various tasks including: design, development and testing of the code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jorge M. Pérez Zerpa (1), leaded and managed the design and development of the code, developed the assembly functions, nonlinear truss element formulation, nonlinear static analysis function, designed and co-authored Newmark's method function, input and output functions, leaded the generation of the documentation.\nJ. Bruno Bazzano (1,2), leaded the development of the nonlinear/linear buckling analysis modules, co-designed the code, developed and implemented validation examples, validated the HHT implementation.\nJoaquín Viera (1), leaded the development of the Linear Analysis module and input files, collaborated in the design and development of the input reading and output generation modules, leaded the development of GUI.\nMauricio Vanzulli (3) co-developed the Newmark's method functions and scripts, developed input files for the dynamic analysis examples.\nMarcelo Forets (4) developed the Neo-Hookean solid model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following authors contributed by :","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jean-Marc Battini (5), contributed functions associated with the computation of static internal forces of the nonlinear frame element.\nSebastian Toro (6), provided the functions: fLectDxf.m, fValGrCode.m and f_XData.m, used in the dxf import function.","category":"page"},{"location":"#Affiliations","page":"Home","title":"Affiliations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Instituto de Estructuras y Transporte, Facultad de Ingeniería, Universidad de la República, Montevideo, Uruguay\nBazzano & Scelza Ingenieros, Montevideo, Uruguay\nInstituto de Ingeniería Mecánica y Producción Industrial, Facultad de Ingeniería, Universidad de la República, Montevideo, Uruguay.\nCentro Universitario Regional Este, Universidad de la República, Maldonado, Uruguay\nDepartment of Civil and Architectural Engineering, KTH Royal Institute of Technology, Stockholm, Sweden\nCIMEC Santa Fe, Argentina","category":"page"},{"location":"#Contributions-and-Acknowledgments","page":"Home","title":"Contributions and Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The functions in linearStiffMatPlate3D.m and assemblyUniform.m use part of the femplateexample.m code developed by Jorge Pérez Zerpa and Pablo Castrillo.","category":"page"},{"location":"","page":"Home","title":"Home","text":"J. M. Pérez Zerpa would like to thank: Pablo Blanco  from the hemolab.lncc.br group at LNCC Brazil,  Gonzalo Ares from Univ. Nacional de Mar del Plata, Gonzalo Maso Talou from  the Auckland Bioengineering Institute and Diego Figueredo  for their numerous comments and suggestions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The development of ONSAS has been partially supported by funds provided by the following agencies/projects:  Comisión de Investigación Científica (CSIC), Comisión Sectorial de Enseñanza (project: Rediseño de prácticas de enseñanza y evaluación en Resistencia de Materiales, manager, Prof. Pérez Zerpa), Agencia Nacional de Investigación e Innovación  (project VIOLETA, code FSE_1_2016_1_131837, manager, Prof. Usera.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can send an e-mail to jorgepz[AT]fing.edu.uy .","category":"page"},{"location":"ONSAS_solve/#ONSAS_solve","page":"ONSAS_solve","title":"ONSAS_solve","text":"","category":"section"},{"location":"ONSAS_solve/","page":"ONSAS_solve","title":"ONSAS_solve","text":"Function that performs the time analysis with the model structs as input.","category":"page"},{"location":"ONSAS_solve/","page":"ONSAS_solve","title":"ONSAS_solve","text":"function [ matUs, loadFactorsMat ] = ONSAS_solve( modelCurrSol, modelProperties, BCsData )","category":"page"},{"location":"ONSAS_solve/","page":"ONSAS_solve","title":"ONSAS_solve","text":"init structures to store solutions","category":"page"},{"location":"ONSAS_solve/","page":"ONSAS_solve","title":"ONSAS_solve","text":"matUs          = modelCurrSol.U              ;\nloadFactorsMat = modelCurrSol.currLoadFactorsVals ;\nmatUdots       = modelCurrSol.Udot           ;\ncellStress     = { modelCurrSol.Stress }     ;","category":"page"},{"location":"ONSAS_solve/#Incremental-time-analysis","page":"ONSAS_solve","title":"Incremental time analysis","text":"","category":"section"},{"location":"ONSAS_solve/","page":"ONSAS_solve","title":"ONSAS_solve","text":"sets stopping boolean to false","category":"page"},{"location":"ONSAS_solve/","page":"ONSAS_solve","title":"ONSAS_solve","text":"finalTimeReachedBoolean = false ;","category":"page"},{"location":"ONSAS_solve/","page":"ONSAS_solve","title":"ONSAS_solve","text":"and starts the iteration","category":"page"},{"location":"ONSAS_solve/","page":"ONSAS_solve","title":"ONSAS_solve","text":"while finalTimeReachedBoolean == false\n\n  % compute the model state at next time\n  modelNextSol = timeStepIteration( modelCurrSol, modelProperties, BCsData ) ;\n\n  % check if final time was reached\n  finalTimeReachedBoolean = ( modelNextSol.currTime - modelProperties.analysisSettings.finalTime ) ...\n                        >= ( -(modelProperties.analysisSettings.finalTime) * 1e-8 ) ;\n\n  % store results and update structs\n  modelCurrSol   =   modelNextSol ;\n  matUs          = [ matUs          modelCurrSol.U                   ] ;\n  loadFactorsMat = [ loadFactorsMat ; modelCurrSol.currLoadFactorsVals ] ;\n\n  % generate vtk file for the new state\n  if strcmp( modelProperties.plotsFormat, 'vtk' )\n    vtkMainWriter( modelCurrSol, modelProperties )\n  end % if vtk output format\n  \nend %while time","category":"page"}]
}
